-- PostgreSQL and TimescaleDB Version Information
                                                      version                                                      
-------------------------------------------------------------------------------------------------------------------
 PostgreSQL 13.13 on x86_64-pc-linux-musl, compiled by gcc (Alpine 12.2.1_git20220924-r10) 12.2.1 20220924, 64-bit
(1 row)

   extname   | extversion 
-------------+------------
 timescaledb | 2.14.0
(1 row)


Output format is unaligned.
-- ================================================================================
-- TIMESCALEDB VIEW COLUMN INFORMATION
-- ================================================================================
schema_name|view_name|columns
_timescaledb_internal|compressed_chunk_stats|hypertable_schema, hypertable_name, chunk_schema, chunk_name, compression_status, uncompressed_heap_size, uncompressed_index_size, uncompressed_toast_size, uncompressed_total_size, compressed_heap_size, compressed_index_size, compressed_toast_size, compressed_total_size
_timescaledb_internal|hypertable_chunk_local_size|hypertable_schema, hypertable_name, hypertable_id, chunk_id, chunk_schema, chunk_name, total_bytes, heap_bytes, index_bytes, toast_bytes, compressed_total_size, compressed_heap_size, compressed_index_size, compressed_toast_size
timescaledb_experimental|policies|relation_name, relation_schema, schedule_interval, proc_schema, proc_name, config, hypertable_schema, hypertable_name
timescaledb_information|chunks|hypertable_schema, hypertable_name, chunk_schema, chunk_name, primary_dimension, primary_dimension_type, range_start, range_end, range_start_integer, range_end_integer, is_compressed, chunk_tablespace, chunk_creation_time
timescaledb_information|compression_settings|hypertable_schema, hypertable_name, attname, segmentby_column_index, orderby_column_index, orderby_asc, orderby_nullsfirst
timescaledb_information|continuous_aggregates|hypertable_schema, hypertable_name, view_schema, view_name, view_owner, materialized_only, compression_enabled, materialization_hypertable_schema, materialization_hypertable_name, view_definition, finalized
timescaledb_information|dimensions|hypertable_schema, hypertable_name, dimension_number, column_name, column_type, dimension_type, time_interval, integer_interval, integer_now_func, num_partitions
timescaledb_information|hypertables|hypertable_schema, hypertable_name, owner, num_dimensions, num_chunks, compression_enabled, tablespaces
timescaledb_information|job_errors|job_id, proc_schema, proc_name, pid, start_time, finish_time, sqlerrcode, err_message
timescaledb_information|job_stats|hypertable_schema, hypertable_name, job_id, last_run_started_at, last_successful_finish, last_run_status, job_status, last_run_duration, next_start, total_runs, total_successes, total_failures
timescaledb_information|jobs|job_id, application_name, schedule_interval, max_runtime, max_retries, retry_period, proc_schema, proc_name, owner, scheduled, fixed_schedule, config, next_start, initial_start, hypertable_schema, hypertable_name, check_schema, check_name

-- ================================================================================
-- TIMESCALEDB FUNCTION INFORMATION
-- ================================================================================
schema_name|function_name|function_args|return_type
_timescaledb_internal|alter_job_set_hypertable_id|job_id integer, hypertable regclass|int4
_timescaledb_internal|attach_osm_table_chunk|hypertable regclass, chunk regclass|bool
_timescaledb_internal|cagg_migrate_create_plan|_cagg_data _timescaledb_catalog.continuous_agg, _cagg_name_new text, _override boolean DEFAULT false, _drop_old boolean DEFAULT false|void
_timescaledb_internal|cagg_migrate_execute_copy_data|_cagg_data _timescaledb_catalog.continuous_agg, _plan_step _timescaledb_catalog.continuous_agg_migrate_plan_step|void
_timescaledb_internal|cagg_migrate_execute_copy_policies|_cagg_data _timescaledb_catalog.continuous_agg, _plan_step _timescaledb_catalog.continuous_agg_migrate_plan_step|void
_timescaledb_internal|cagg_migrate_execute_create_new_cagg|_cagg_data _timescaledb_catalog.continuous_agg, _plan_step _timescaledb_catalog.continuous_agg_migrate_plan_step|void
_timescaledb_internal|cagg_migrate_execute_disable_policies|_cagg_data _timescaledb_catalog.continuous_agg, _plan_step _timescaledb_catalog.continuous_agg_migrate_plan_step|void
_timescaledb_internal|cagg_migrate_execute_drop_old_cagg|_cagg_data _timescaledb_catalog.continuous_agg, _plan_step _timescaledb_catalog.continuous_agg_migrate_plan_step|void
_timescaledb_internal|cagg_migrate_execute_enable_policies|_cagg_data _timescaledb_catalog.continuous_agg, _plan_step _timescaledb_catalog.continuous_agg_migrate_plan_step|void
_timescaledb_internal|cagg_migrate_execute_override_cagg|_cagg_data _timescaledb_catalog.continuous_agg, _plan_step _timescaledb_catalog.continuous_agg_migrate_plan_step|void
_timescaledb_internal|cagg_migrate_execute_plan|_cagg_data _timescaledb_catalog.continuous_agg|void
_timescaledb_internal|cagg_migrate_execute_refresh_new_cagg|_cagg_data _timescaledb_catalog.continuous_agg, _plan_step _timescaledb_catalog.continuous_agg_migrate_plan_step|void
_timescaledb_internal|cagg_migrate_plan_exists|_hypertable_id integer|bool
_timescaledb_internal|cagg_migrate_pre_validation|_cagg_schema text, _cagg_name text, _cagg_name_new text|continuous_agg
_timescaledb_internal|cagg_watermark|hypertable_id integer|int8
_timescaledb_internal|cagg_watermark_materialized|hypertable_id integer|int8
_timescaledb_internal|calculate_chunk_interval|dimension_id integer, dimension_coord bigint, chunk_target_size bigint|int8
_timescaledb_internal|chunk_constraint_add_table_constraint|chunk_constraint_row _timescaledb_catalog.chunk_constraint|void
_timescaledb_internal|chunk_id_from_relid|relid oid|int4
_timescaledb_internal|chunk_index_clone|chunk_index_oid oid|oid
_timescaledb_internal|chunk_index_replace|chunk_index_oid_old oid, chunk_index_oid_new oid|void
_timescaledb_internal|chunk_status|regclass|int4
_timescaledb_internal|chunks_local_size|schema_name_in name, table_name_in name|record
_timescaledb_internal|compressed_chunk_local_stats|schema_name_in name, table_name_in name|record
_timescaledb_internal|compressed_chunk_remote_stats|schema_name_in name, table_name_in name|record
_timescaledb_internal|continuous_agg_invalidation_trigger||trigger
_timescaledb_internal|create_chunk|hypertable regclass, _slices jsonb, _schema_name name DEFAULT NULL::name, _table_name name DEFAULT NULL::name, chunk_table regclass DEFAULT NULL::regclass|record
_timescaledb_internal|create_chunk_table|hypertable regclass, slices jsonb, schema_name name, table_name name|bool
_timescaledb_internal|create_compressed_chunk|chunk regclass, chunk_table regclass, uncompressed_heap_size bigint, uncompressed_toast_size bigint, uncompressed_index_size bigint, compressed_heap_size bigint, compressed_toast_size bigint, compressed_index_size bigint, numrows_pre_compression bigint, numrows_post_compression bigint|regclass
_timescaledb_internal|drop_chunk|chunk regclass|bool
_timescaledb_internal|finalize_agg|agg_name text, inner_agg_collation_schema name, inner_agg_collation_name name, inner_agg_input_types name[], inner_agg_serialized_state bytea, return_type_dummy_val anyelement|anyelement
_timescaledb_internal|finalize_agg_ffunc|tstate internal, aggfn text, inner_agg_collation_schema name, inner_agg_collation_name name, inner_agg_input_types name[], inner_agg_serialized_state bytea, return_type_dummy_val anyelement|anyelement
_timescaledb_internal|finalize_agg_sfunc|tstate internal, aggfn text, inner_agg_collation_schema name, inner_agg_collation_name name, inner_agg_input_types name[], inner_agg_serialized_state bytea, return_type_dummy_val anyelement|internal
_timescaledb_internal|freeze_chunk|chunk regclass|bool
_timescaledb_internal|generate_uuid||uuid
_timescaledb_internal|get_approx_row_count|relation regclass|int8
_timescaledb_internal|get_chunk_colstats|relid regclass|record
_timescaledb_internal|get_chunk_relstats|relid regclass|record
_timescaledb_internal|get_compressed_chunk_index_for_recompression|uncompressed_chunk regclass|regclass
_timescaledb_internal|get_create_command|table_name name|text
_timescaledb_internal|get_git_commit||record
_timescaledb_internal|get_os_info||record
_timescaledb_internal|get_partition_for_key|val anyelement|int4
_timescaledb_internal|get_partition_hash|val anyelement|int4
_timescaledb_internal|hypertable_invalidation_log_delete|raw_hypertable_id integer|void
_timescaledb_internal|hypertable_local_size|schema_name_in name, table_name_in name|record
_timescaledb_internal|indexes_local_size|schema_name_in name, table_name_in name|record
_timescaledb_internal|insert_blocker||trigger
_timescaledb_internal|interval_to_usec|chunk_interval interval|int8
_timescaledb_internal|invalidation_cagg_log_add_entry|mat_hypertable_id integer, start_time bigint, end_time bigint|void
_timescaledb_internal|invalidation_hyper_log_add_entry|raw_hypertable_id integer, start_time bigint, end_time bigint|void
_timescaledb_internal|invalidation_process_cagg_log|mat_hypertable_id integer, raw_hypertable_id integer, dimtype regtype, window_start bigint, window_end bigint, mat_hypertable_ids integer[], bucket_widths bigint[], max_bucket_widths bigint[], bucket_functions text[]|record
_timescaledb_internal|invalidation_process_cagg_log|mat_hypertable_id integer, raw_hypertable_id integer, dimtype regtype, window_start bigint, window_end bigint, mat_hypertable_ids integer[], bucket_widths bigint[], max_bucket_widths bigint[]|record
_timescaledb_internal|invalidation_process_hypertable_log|mat_hypertable_id integer, raw_hypertable_id integer, dimtype regtype, mat_hypertable_ids integer[], bucket_widths bigint[], max_bucket_widths bigint[], bucket_functions text[]|void
_timescaledb_internal|invalidation_process_hypertable_log|mat_hypertable_id integer, raw_hypertable_id integer, dimtype regtype, mat_hypertable_ids integer[], bucket_widths bigint[], max_bucket_widths bigint[]|void
_timescaledb_internal|materialization_invalidation_log_delete|mat_hypertable_id integer|void
_timescaledb_internal|partialize_agg|arg anyelement|bytea
_timescaledb_internal|policy_compression|job_id integer, config jsonb|void
_timescaledb_internal|policy_compression_check|config jsonb|void
_timescaledb_internal|policy_compression_execute|job_id integer, htid integer, lag anyelement, maxchunks integer, verbose_log boolean, recompress_enabled boolean, use_creation_time boolean|void
_timescaledb_internal|policy_job_error_retention|job_id integer, config jsonb|int4
_timescaledb_internal|policy_job_error_retention_check|config jsonb|void
_timescaledb_internal|policy_recompression|job_id integer, config jsonb|void
_timescaledb_internal|policy_refresh_continuous_aggregate|job_id integer, config jsonb|void
_timescaledb_internal|policy_refresh_continuous_aggregate_check|config jsonb|void
_timescaledb_internal|policy_reorder|job_id integer, config jsonb|void
_timescaledb_internal|policy_reorder_check|config jsonb|void
_timescaledb_internal|policy_retention|job_id integer, config jsonb|void
_timescaledb_internal|policy_retention_check|config jsonb|void
_timescaledb_internal|process_ddl_event||event_trigger
_timescaledb_internal|range_value_to_pretty|time_value bigint, column_type regtype|text
_timescaledb_internal|recompress_chunk_segmentwise|uncompressed_chunk regclass, if_compressed boolean DEFAULT false|regclass
_timescaledb_internal|relation_size|relation regclass|record
_timescaledb_internal|restart_background_workers||bool
_timescaledb_internal|show_chunk|chunk regclass|record
_timescaledb_internal|start_background_workers||bool
_timescaledb_internal|stop_background_workers||bool
_timescaledb_internal|subtract_integer_from_now|hypertable_relid regclass, lag bigint|int8
_timescaledb_internal|time_to_internal|time_val anyelement|int8
_timescaledb_internal|to_date|unixtime_us bigint|date
_timescaledb_internal|to_interval|unixtime_us bigint|interval
_timescaledb_internal|to_timestamp|unixtime_us bigint|timestamptz
_timescaledb_internal|to_timestamp_without_timezone|unixtime_us bigint|timestamp
_timescaledb_internal|to_unix_microseconds|ts timestamp with time zone|int8
_timescaledb_internal|tsl_loaded||bool
_timescaledb_internal|unfreeze_chunk|chunk regclass|bool
public|add_compression_policy|hypertable regclass, compress_after "any" DEFAULT NULL::unknown, if_not_exists boolean DEFAULT false, schedule_interval interval DEFAULT NULL::interval, initial_start timestamp with time zone DEFAULT NULL::timestamp with time zone, timezone text DEFAULT NULL::text, compress_created_before interval DEFAULT NULL::interval|int4
public|add_continuous_aggregate_policy|continuous_aggregate regclass, start_offset "any", end_offset "any", schedule_interval interval, if_not_exists boolean DEFAULT false, initial_start timestamp with time zone DEFAULT NULL::timestamp with time zone, timezone text DEFAULT NULL::text|int4
public|add_dimension|hypertable regclass, column_name name, number_partitions integer DEFAULT NULL::integer, chunk_time_interval anyelement DEFAULT NULL::bigint, partitioning_func regproc DEFAULT NULL::regproc, if_not_exists boolean DEFAULT false|record
public|add_dimension|hypertable regclass, dimension _timescaledb_internal.dimension_info, if_not_exists boolean DEFAULT false|record
public|add_job|proc regproc, schedule_interval interval, config jsonb DEFAULT NULL::jsonb, initial_start timestamp with time zone DEFAULT NULL::timestamp with time zone, scheduled boolean DEFAULT true, check_config regproc DEFAULT NULL::regproc, fixed_schedule boolean DEFAULT true, timezone text DEFAULT NULL::text|int4
public|add_reorder_policy|hypertable regclass, index_name name, if_not_exists boolean DEFAULT false, initial_start timestamp with time zone DEFAULT NULL::timestamp with time zone, timezone text DEFAULT NULL::text|int4
public|add_retention_policy|relation regclass, drop_after "any" DEFAULT NULL::unknown, if_not_exists boolean DEFAULT false, schedule_interval interval DEFAULT NULL::interval, initial_start timestamp with time zone DEFAULT NULL::timestamp with time zone, timezone text DEFAULT NULL::text, drop_created_before interval DEFAULT NULL::interval|int4
public|alter_job|job_id integer, schedule_interval interval DEFAULT NULL::interval, max_runtime interval DEFAULT NULL::interval, max_retries integer DEFAULT NULL::integer, retry_period interval DEFAULT NULL::interval, scheduled boolean DEFAULT NULL::boolean, config jsonb DEFAULT NULL::jsonb, next_start timestamp with time zone DEFAULT NULL::timestamp with time zone, if_exists boolean DEFAULT false, check_config regproc DEFAULT NULL::regproc, fixed_schedule boolean DEFAULT NULL::boolean, initial_start timestamp with time zone DEFAULT NULL::timestamp with time zone, timezone text DEFAULT NULL::text|record
public|chunk_compression_stats|hypertable regclass|record
public|chunks_detailed_size|hypertable regclass|record
public|compress_chunk|uncompressed_chunk regclass, if_not_compressed boolean DEFAULT true, recompress boolean DEFAULT false|regclass
public|create_hypertable|relation regclass, dimension _timescaledb_internal.dimension_info, create_default_indexes boolean DEFAULT true, if_not_exists boolean DEFAULT false, migrate_data boolean DEFAULT false|record
public|create_hypertable|relation regclass, time_column_name name, partitioning_column name DEFAULT NULL::name, number_partitions integer DEFAULT NULL::integer, associated_schema_name name DEFAULT NULL::name, associated_table_prefix name DEFAULT NULL::name, chunk_time_interval anyelement DEFAULT NULL::bigint, create_default_indexes boolean DEFAULT true, if_not_exists boolean DEFAULT false, partitioning_func regproc DEFAULT NULL::regproc, migrate_data boolean DEFAULT false, chunk_target_size text DEFAULT NULL::text, chunk_sizing_func regproc DEFAULT '_timescaledb_functions.calculate_chunk_interval'::regproc, time_partitioning_func regproc DEFAULT NULL::regproc|record
public|decompress_chunk|uncompressed_chunk regclass, if_compressed boolean DEFAULT true|regclass
public|delete_job|job_id integer|void
public|drop_chunks|relation regclass, older_than "any" DEFAULT NULL::unknown, newer_than "any" DEFAULT NULL::unknown, "verbose" boolean DEFAULT false, created_before "any" DEFAULT NULL::unknown, created_after "any" DEFAULT NULL::unknown|text
public|hypertable_approximate_detailed_size|relation regclass|record
public|hypertable_approximate_size|hypertable regclass|int8
public|hypertable_compression_stats|hypertable regclass|record
public|hypertable_detailed_size|hypertable regclass|record
public|hypertable_index_size|index_name regclass|int8
public|hypertable_size|hypertable regclass|int8
public|move_chunk|chunk regclass, destination_tablespace name, index_destination_tablespace name DEFAULT NULL::name, reorder_index regclass DEFAULT NULL::regclass, "verbose" boolean DEFAULT false|void
public|recompress_chunk|chunk regclass, if_not_compressed boolean DEFAULT true|void
public|refresh_continuous_aggregate|continuous_aggregate regclass, window_start "any", window_end "any"|void
public|remove_compression_policy|hypertable regclass, if_exists boolean DEFAULT false|bool
public|remove_continuous_aggregate_policy|continuous_aggregate regclass, if_not_exists boolean DEFAULT false, if_exists boolean DEFAULT NULL::boolean|void
public|remove_reorder_policy|hypertable regclass, if_exists boolean DEFAULT false|void
public|remove_retention_policy|relation regclass, if_exists boolean DEFAULT false|void
public|reorder_chunk|chunk regclass, index regclass DEFAULT NULL::regclass, "verbose" boolean DEFAULT false|void
public|run_job|job_id integer|void
public|set_adaptive_chunking|hypertable regclass, chunk_target_size text, INOUT chunk_sizing_func regproc DEFAULT '_timescaledb_functions.calculate_chunk_interval'::regproc, OUT chunk_target_size bigint|record
public|set_chunk_time_interval|hypertable regclass, chunk_time_interval anyelement, dimension_name name DEFAULT NULL::name|void
public|show_chunks|relation regclass, older_than "any" DEFAULT NULL::unknown, newer_than "any" DEFAULT NULL::unknown, created_before "any" DEFAULT NULL::unknown, created_after "any" DEFAULT NULL::unknown|regclass
public|timescaledb_post_restore||bool
public|timescaledb_pre_restore||bool
timescaledb_experimental|add_policies|relation regclass, if_not_exists boolean DEFAULT false, refresh_start_offset "any" DEFAULT NULL::unknown, refresh_end_offset "any" DEFAULT NULL::unknown, compress_after "any" DEFAULT NULL::unknown, drop_after "any" DEFAULT NULL::unknown|bool
timescaledb_experimental|alter_policies|relation regclass, if_exists boolean DEFAULT false, refresh_start_offset "any" DEFAULT NULL::unknown, refresh_end_offset "any" DEFAULT NULL::unknown, compress_after "any" DEFAULT NULL::unknown, drop_after "any" DEFAULT NULL::unknown|bool
timescaledb_experimental|remove_all_policies|relation regclass, if_exists boolean DEFAULT false|bool
timescaledb_experimental|remove_policies|relation regclass, if_exists boolean DEFAULT false, VARIADIC policy_names text[] DEFAULT NULL::text[]|bool
timescaledb_experimental|show_policies|relation regclass|jsonb
timescaledb_experimental|time_bucket_ng|bucket_width interval, ts timestamp with time zone, timezone text|timestamptz
timescaledb_experimental|time_bucket_ng|bucket_width interval, ts timestamp without time zone|timestamp
timescaledb_experimental|time_bucket_ng|bucket_width interval, ts timestamp with time zone, origin timestamp with time zone, timezone text|timestamptz
timescaledb_experimental|time_bucket_ng|bucket_width interval, ts timestamp with time zone|timestamptz
timescaledb_experimental|time_bucket_ng|bucket_width interval, ts timestamp with time zone, origin timestamp with time zone|timestamptz
timescaledb_experimental|time_bucket_ng|bucket_width interval, ts date, origin date|date
timescaledb_experimental|time_bucket_ng|bucket_width interval, ts timestamp without time zone, origin timestamp without time zone|timestamp
timescaledb_experimental|time_bucket_ng|bucket_width interval, ts date|date

-- ================================================================================
-- TIMESCALEDB VIEW DEFINITIONS
-- ================================================================================
Field separator is "|
".
schema_name|
view_name|
definition
_timescaledb_internal|
compressed_chunk_stats|
 SELECT srcht.schema_name AS hypertable_schema,
    srcht.table_name AS hypertable_name,
    srcch.schema_name AS chunk_schema,
    srcch.table_name AS chunk_name,
        CASE
            WHEN srcch.compressed_chunk_id IS NULL THEN 'Uncompressed'::text
            ELSE 'Compressed'::text
        END AS compression_status,
    map.uncompressed_heap_size,
    map.uncompressed_index_size,
    map.uncompressed_toast_size,
    map.uncompressed_heap_size + map.uncompressed_toast_size + map.uncompressed_index_size AS uncompressed_total_size,
    map.compressed_heap_size,
    map.compressed_index_size,
    map.compressed_toast_size,
    map.compressed_heap_size + map.compressed_toast_size + map.compressed_index_size AS compressed_total_size
   FROM _timescaledb_catalog.hypertable srcht
     JOIN _timescaledb_catalog.chunk srcch ON srcht.id = srcch.hypertable_id AND srcht.compressed_hypertable_id IS NOT NULL AND srcch.dropped = false
     LEFT JOIN _timescaledb_catalog.compression_chunk_size map ON srcch.id = map.chunk_id;
_timescaledb_internal|
hypertable_chunk_local_size|
 SELECT h.schema_name AS hypertable_schema,
    h.table_name AS hypertable_name,
    h.id AS hypertable_id,
    c.id AS chunk_id,
    c.schema_name AS chunk_schema,
    c.table_name AS chunk_name,
    COALESCE(relsize.total_size, 0::bigint) AS total_bytes,
    COALESCE(relsize.heap_size, 0::bigint) AS heap_bytes,
    COALESCE(relsize.index_size, 0::bigint) AS index_bytes,
    COALESCE(relsize.toast_size, 0::bigint) AS toast_bytes,
    COALESCE(relcompsize.total_size, 0::bigint) AS compressed_total_size,
    COALESCE(relcompsize.heap_size, 0::bigint) AS compressed_heap_size,
    COALESCE(relcompsize.index_size, 0::bigint) AS compressed_index_size,
    COALESCE(relcompsize.toast_size, 0::bigint) AS compressed_toast_size
   FROM _timescaledb_catalog.hypertable h
     JOIN _timescaledb_catalog.chunk c ON h.id = c.hypertable_id AND c.dropped IS FALSE
     JOIN pg_class cl ON cl.relname = c.table_name AND cl.relkind = 'r'::"char"
     JOIN pg_namespace n ON n.oid = cl.relnamespace AND n.nspname = c.schema_name
     JOIN LATERAL _timescaledb_functions.relation_size(cl.oid::regclass) relsize(total_size, heap_size, index_size, toast_size) ON true
     LEFT JOIN _timescaledb_catalog.chunk comp ON comp.id = c.compressed_chunk_id
     LEFT JOIN LATERAL _timescaledb_functions.relation_size(
        CASE
            WHEN comp.schema_name IS NOT NULL AND comp.table_name IS NOT NULL THEN format('%I.%I'::text, comp.schema_name, comp.table_name)::regclass
            ELSE NULL::regclass
        END) relcompsize(total_size, heap_size, index_size, toast_size) ON true;
timescaledb_experimental|
policies|
 SELECT ca.user_view_name AS relation_name,
    ca.user_view_schema AS relation_schema,
    j.schedule_interval,
    j.proc_schema,
    j.proc_name,
    j.config,
    ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name
   FROM _timescaledb_config.bgw_job j
     JOIN _timescaledb_catalog.continuous_agg ca ON ca.mat_hypertable_id = j.hypertable_id
     JOIN _timescaledb_catalog.hypertable ht ON ht.id = ca.mat_hypertable_id;
timescaledb_information|
chunks|
 SELECT finalq.hypertable_schema,
    finalq.hypertable_name,
    finalq.schema_name AS chunk_schema,
    finalq.chunk_name,
    finalq.primary_dimension,
    finalq.primary_dimension_type,
    finalq.range_start,
    finalq.range_end,
    finalq.integer_range_start AS range_start_integer,
    finalq.integer_range_end AS range_end_integer,
    finalq.is_compressed,
    finalq.chunk_table_space AS chunk_tablespace,
    finalq.creation_time AS chunk_creation_time
   FROM ( SELECT ht.schema_name AS hypertable_schema,
            ht.table_name AS hypertable_name,
            srcch.schema_name,
            srcch.table_name AS chunk_name,
            dim.column_name AS primary_dimension,
            dim.column_type AS primary_dimension_type,
            row_number() OVER (PARTITION BY chcons.chunk_id ORDER BY dim.id) AS chunk_dimension_num,
                CASE
                    WHEN dim.column_type::oid = 'timestamp without time zone'::regtype::oid OR dim.column_type::oid = 'timestamp with time zone'::regtype::oid OR dim.column_type::oid = 'date'::regtype::oid THEN _timescaledb_functions.to_timestamp(dimsl.range_start)
                    ELSE NULL::timestamp with time zone
                END AS range_start,
                CASE
                    WHEN dim.column_type::oid = 'timestamp without time zone'::regtype::oid OR dim.column_type::oid = 'timestamp with time zone'::regtype::oid OR dim.column_type::oid = 'date'::regtype::oid THEN _timescaledb_functions.to_timestamp(dimsl.range_end)
                    ELSE NULL::timestamp with time zone
                END AS range_end,
                CASE
                    WHEN dim.column_type::oid = 'timestamp without time zone'::regtype::oid OR dim.column_type::oid = 'timestamp with time zone'::regtype::oid OR dim.column_type::oid = 'date'::regtype::oid THEN NULL::bigint
                    ELSE dimsl.range_start
                END AS integer_range_start,
                CASE
                    WHEN dim.column_type::oid = 'timestamp without time zone'::regtype::oid OR dim.column_type::oid = 'timestamp with time zone'::regtype::oid OR dim.column_type::oid = 'date'::regtype::oid THEN NULL::bigint
                    ELSE dimsl.range_end
                END AS integer_range_end,
                CASE
                    WHEN (srcch.status & 1) = 1 THEN true
                    ELSE false
                END AS is_compressed,
            pgtab.spcname AS chunk_table_space,
            srcch.creation_time
           FROM _timescaledb_catalog.chunk srcch
             JOIN _timescaledb_catalog.hypertable ht ON ht.id = srcch.hypertable_id
             JOIN _timescaledb_catalog.chunk_constraint chcons ON srcch.id = chcons.chunk_id
             JOIN _timescaledb_catalog.dimension dim ON srcch.hypertable_id = dim.hypertable_id
             JOIN _timescaledb_catalog.dimension_slice dimsl ON dim.id = dimsl.dimension_id AND chcons.dimension_slice_id = dimsl.id
             JOIN ( SELECT pg_class.relname,
                    pg_class.reltablespace,
                    pg_namespace.nspname AS schema_name
                   FROM pg_class,
                    pg_namespace
                  WHERE pg_class.relnamespace = pg_namespace.oid) cl ON srcch.table_name = cl.relname AND srcch.schema_name = cl.schema_name
             LEFT JOIN pg_tablespace pgtab ON pgtab.oid = cl.reltablespace
          WHERE srcch.dropped IS FALSE AND srcch.osm_chunk IS FALSE AND ht.compression_state <> 2) finalq
  WHERE finalq.chunk_dimension_num = 1;
timescaledb_information|
compression_settings|
 SELECT ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    unnest(cs.segmentby)::name COLLATE "C" AS attname,
    generate_series(1, array_length(cs.segmentby, 1))::smallint AS segmentby_column_index,
    NULL::smallint AS orderby_column_index,
    NULL::boolean AS orderby_asc,
    NULL::boolean AS orderby_nullsfirst
   FROM _timescaledb_catalog.hypertable ht
     JOIN _timescaledb_catalog.compression_settings cs ON cs.relid::oid = format('%I.%I'::text, ht.schema_name, ht.table_name)::regclass::oid AND cs.segmentby IS NOT NULL
  WHERE ht.compressed_hypertable_id IS NOT NULL
UNION ALL
 SELECT ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    unnest(cs.orderby)::name COLLATE "C" AS attname,
    NULL::smallint AS segmentby_column_index,
    generate_series(1, array_length(cs.orderby, 1))::smallint AS orderby_column_index,
    unnest(array_replace(array_replace(array_replace(cs.orderby_desc, false, NULL::boolean), true, false), NULL::boolean, true)) AS orderby_asc,
    unnest(cs.orderby_nullsfirst) AS orderby_nullsfirst
   FROM _timescaledb_catalog.hypertable ht
     JOIN _timescaledb_catalog.compression_settings cs ON cs.relid::oid = format('%I.%I'::text, ht.schema_name, ht.table_name)::regclass::oid AND cs.orderby IS NOT NULL
  WHERE ht.compressed_hypertable_id IS NOT NULL
  ORDER BY 2, 4, 5;
timescaledb_information|
continuous_aggregates|
 SELECT ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    cagg.user_view_schema AS view_schema,
    cagg.user_view_name AS view_name,
    viewinfo.viewowner AS view_owner,
    cagg.materialized_only,
        CASE
            WHEN mat_ht.compressed_hypertable_id IS NOT NULL THEN true
            ELSE false
        END AS compression_enabled,
    mat_ht.schema_name AS materialization_hypertable_schema,
    mat_ht.table_name AS materialization_hypertable_name,
    directview.viewdefinition AS view_definition,
    cagg.finalized
   FROM _timescaledb_catalog.continuous_agg cagg,
    _timescaledb_catalog.hypertable ht,
    LATERAL ( SELECT c.oid,
            pg_get_userbyid(c.relowner) AS viewowner
           FROM pg_class c
             LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
          WHERE c.relkind = 'v'::"char" AND c.relname = cagg.user_view_name AND n.nspname = cagg.user_view_schema) viewinfo,
    LATERAL ( SELECT pg_get_viewdef(c.oid) AS viewdefinition
           FROM pg_class c
             LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
          WHERE c.relkind = 'v'::"char" AND c.relname = cagg.direct_view_name AND n.nspname = cagg.direct_view_schema) directview,
    LATERAL ( SELECT hypertable.schema_name,
            hypertable.table_name,
            hypertable.compressed_hypertable_id
           FROM _timescaledb_catalog.hypertable
          WHERE cagg.mat_hypertable_id = hypertable.id) mat_ht
  WHERE cagg.raw_hypertable_id = ht.id;
timescaledb_information|
dimensions|
 SELECT ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    rank() OVER (PARTITION BY dim.hypertable_id ORDER BY dim.id) AS dimension_number,
    dim.column_name,
    dim.column_type,
        CASE
            WHEN dim.interval_length IS NULL THEN 'Space'::text
            ELSE 'Time'::text
        END AS dimension_type,
        CASE
            WHEN dim.interval_length IS NOT NULL THEN
            CASE
                WHEN dim.column_type::oid = 'timestamp without time zone'::regtype::oid OR dim.column_type::oid = 'timestamp with time zone'::regtype::oid OR dim.column_type::oid = 'date'::regtype::oid THEN _timescaledb_functions.to_interval(dim.interval_length)
                ELSE NULL::interval
            END
            ELSE NULL::interval
        END AS time_interval,
        CASE
            WHEN dim.interval_length IS NOT NULL THEN
            CASE
                WHEN dim.column_type::oid = 'timestamp without time zone'::regtype::oid OR dim.column_type::oid = 'timestamp with time zone'::regtype::oid OR dim.column_type::oid = 'date'::regtype::oid THEN NULL::bigint
                ELSE dim.interval_length
            END
            ELSE NULL::bigint
        END AS integer_interval,
    dim.integer_now_func,
    dim.num_slices AS num_partitions
   FROM _timescaledb_catalog.hypertable ht,
    _timescaledb_catalog.dimension dim
  WHERE dim.hypertable_id = ht.id;
timescaledb_information|
hypertables|
 SELECT ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    t.tableowner AS owner,
    ht.num_dimensions,
    ( SELECT count(1) AS count
           FROM _timescaledb_catalog.chunk ch
          WHERE ch.hypertable_id = ht.id AND ch.dropped IS FALSE AND ch.osm_chunk IS FALSE) AS num_chunks,
        CASE
            WHEN ht.compression_state = 1 THEN true
            ELSE false
        END AS compression_enabled,
    srchtbs.tablespace_list AS tablespaces
   FROM _timescaledb_catalog.hypertable ht
     JOIN pg_tables t ON ht.table_name = t.tablename AND ht.schema_name = t.schemaname
     LEFT JOIN _timescaledb_catalog.continuous_agg ca ON ca.mat_hypertable_id = ht.id
     LEFT JOIN ( SELECT tablespace.hypertable_id,
            array_agg(tablespace.tablespace_name ORDER BY tablespace.id) AS tablespace_list
           FROM _timescaledb_catalog.tablespace
          GROUP BY tablespace.hypertable_id) srchtbs ON ht.id = srchtbs.hypertable_id
  WHERE ht.compression_state <> 2 AND ca.mat_hypertable_id IS NULL;
timescaledb_information|
job_errors|
 SELECT job_errors.job_id,
    job_errors.error_data ->> 'proc_schema'::text AS proc_schema,
    job_errors.error_data ->> 'proc_name'::text AS proc_name,
    job_errors.pid,
    job_errors.start_time,
    job_errors.finish_time,
    job_errors.error_data ->> 'sqlerrcode'::text AS sqlerrcode,
        CASE
            WHEN (job_errors.error_data ->> 'message'::text) IS NOT NULL THEN
            CASE
                WHEN (job_errors.error_data ->> 'detail'::text) IS NOT NULL THEN
                CASE
                    WHEN (job_errors.error_data ->> 'hint'::text) IS NOT NULL THEN concat(job_errors.error_data ->> 'message'::text, '. ', job_errors.error_data ->> 'detail'::text, '. ', job_errors.error_data ->> 'hint'::text)
                    ELSE concat(job_errors.error_data ->> 'message'::text, ' ', job_errors.error_data ->> 'detail'::text)
                END
                ELSE
                CASE
                    WHEN (job_errors.error_data ->> 'hint'::text) IS NOT NULL THEN concat(job_errors.error_data ->> 'message'::text, '. ', job_errors.error_data ->> 'hint'::text)
                    ELSE job_errors.error_data ->> 'message'::text
                END
            END
            ELSE 'job crash detected, see server logs'::text
        END AS err_message
   FROM _timescaledb_internal.job_errors
     LEFT JOIN _timescaledb_config.bgw_job ON bgw_job.id = job_errors.job_id
  WHERE pg_has_role(CURRENT_USER, ( SELECT pg_get_userbyid(pg_database.datdba) AS pg_get_userbyid
           FROM pg_database
          WHERE pg_database.datname = current_database()), 'MEMBER'::text) IS TRUE OR pg_has_role(CURRENT_USER, bgw_job.owner::oid, 'MEMBER'::text) IS TRUE;
timescaledb_information|
job_stats|
 SELECT ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    j.id AS job_id,
    js.last_start AS last_run_started_at,
    js.last_successful_finish,
        CASE
            WHEN js.last_finish < '4714-11-24 00:00:00+00 BC'::timestamp with time zone THEN NULL::text
            WHEN js.last_finish IS NOT NULL THEN
            CASE
                WHEN js.last_run_success = true THEN 'Success'::text
                WHEN js.last_run_success = false THEN 'Failed'::text
                ELSE NULL::text
            END
            ELSE NULL::text
        END AS last_run_status,
        CASE
            WHEN pgs.state = 'active'::text THEN 'Running'::text
            WHEN j.scheduled = false THEN 'Paused'::text
            ELSE 'Scheduled'::text
        END AS job_status,
        CASE
            WHEN js.last_finish > js.last_start THEN js.last_finish - js.last_start
            ELSE NULL::interval
        END AS last_run_duration,
        CASE
            WHEN j.scheduled THEN js.next_start
            ELSE NULL::timestamp with time zone
        END AS next_start,
    js.total_runs,
    js.total_successes,
    js.total_failures
   FROM _timescaledb_config.bgw_job j
     JOIN _timescaledb_internal.bgw_job_stat js ON j.id = js.job_id
     LEFT JOIN _timescaledb_catalog.hypertable ht ON j.hypertable_id = ht.id
     LEFT JOIN pg_stat_activity pgs ON pgs.datname = current_database() AND pgs.application_name = j.application_name
  ORDER BY ht.schema_name, ht.table_name;
timescaledb_information|
jobs|
 SELECT j.id AS job_id,
    j.application_name,
    j.schedule_interval,
    j.max_runtime,
    j.max_retries,
    j.retry_period,
    j.proc_schema,
    j.proc_name,
    j.owner,
    j.scheduled,
    j.fixed_schedule,
    j.config,
    js.next_start,
    j.initial_start,
    ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    j.check_schema,
    j.check_name
   FROM _timescaledb_config.bgw_job j
     LEFT JOIN _timescaledb_catalog.hypertable ht ON ht.id = j.hypertable_id
     LEFT JOIN _timescaledb_internal.bgw_job_stat js ON js.job_id = j.id;

-- ================================================================================
-- TIMESCALEDB INFORMATION SCHEMA VIEWS
-- ================================================================================
schemaname|
viewname|
viewowner|
definition
timescaledb_experimental|
policies|
postgres|
 SELECT ca.user_view_name AS relation_name,
    ca.user_view_schema AS relation_schema,
    j.schedule_interval,
    j.proc_schema,
    j.proc_name,
    j.config,
    ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name
   FROM ((_timescaledb_config.bgw_job j
     JOIN _timescaledb_catalog.continuous_agg ca ON ((ca.mat_hypertable_id = j.hypertable_id)))
     JOIN _timescaledb_catalog.hypertable ht ON ((ht.id = ca.mat_hypertable_id)));
timescaledb_information|
chunks|
postgres|
 SELECT finalq.hypertable_schema,
    finalq.hypertable_name,
    finalq.schema_name AS chunk_schema,
    finalq.chunk_name,
    finalq.primary_dimension,
    finalq.primary_dimension_type,
    finalq.range_start,
    finalq.range_end,
    finalq.integer_range_start AS range_start_integer,
    finalq.integer_range_end AS range_end_integer,
    finalq.is_compressed,
    finalq.chunk_table_space AS chunk_tablespace,
    finalq.creation_time AS chunk_creation_time
   FROM ( SELECT ht.schema_name AS hypertable_schema,
            ht.table_name AS hypertable_name,
            srcch.schema_name,
            srcch.table_name AS chunk_name,
            dim.column_name AS primary_dimension,
            dim.column_type AS primary_dimension_type,
            row_number() OVER (PARTITION BY chcons.chunk_id ORDER BY dim.id) AS chunk_dimension_num,
                CASE
                    WHEN (((dim.column_type)::oid = ('timestamp without time zone'::regtype)::oid) OR ((dim.column_type)::oid = ('timestamp with time zone'::regtype)::oid) OR ((dim.column_type)::oid = ('date'::regtype)::oid)) THEN _timescaledb_functions.to_timestamp(dimsl.range_start)
                    ELSE NULL::timestamp with time zone
                END AS range_start,
                CASE
                    WHEN (((dim.column_type)::oid = ('timestamp without time zone'::regtype)::oid) OR ((dim.column_type)::oid = ('timestamp with time zone'::regtype)::oid) OR ((dim.column_type)::oid = ('date'::regtype)::oid)) THEN _timescaledb_functions.to_timestamp(dimsl.range_end)
                    ELSE NULL::timestamp with time zone
                END AS range_end,
                CASE
                    WHEN (((dim.column_type)::oid = ('timestamp without time zone'::regtype)::oid) OR ((dim.column_type)::oid = ('timestamp with time zone'::regtype)::oid) OR ((dim.column_type)::oid = ('date'::regtype)::oid)) THEN NULL::bigint
                    ELSE dimsl.range_start
                END AS integer_range_start,
                CASE
                    WHEN (((dim.column_type)::oid = ('timestamp without time zone'::regtype)::oid) OR ((dim.column_type)::oid = ('timestamp with time zone'::regtype)::oid) OR ((dim.column_type)::oid = ('date'::regtype)::oid)) THEN NULL::bigint
                    ELSE dimsl.range_end
                END AS integer_range_end,
                CASE
                    WHEN ((srcch.status & 1) = 1) THEN true
                    ELSE false
                END AS is_compressed,
            pgtab.spcname AS chunk_table_space,
            srcch.creation_time
           FROM ((((((_timescaledb_catalog.chunk srcch
             JOIN _timescaledb_catalog.hypertable ht ON ((ht.id = srcch.hypertable_id)))
             JOIN _timescaledb_catalog.chunk_constraint chcons ON ((srcch.id = chcons.chunk_id)))
             JOIN _timescaledb_catalog.dimension dim ON ((srcch.hypertable_id = dim.hypertable_id)))
             JOIN _timescaledb_catalog.dimension_slice dimsl ON (((dim.id = dimsl.dimension_id) AND (chcons.dimension_slice_id = dimsl.id))))
             JOIN ( SELECT pg_class.relname,
                    pg_class.reltablespace,
                    pg_namespace.nspname AS schema_name
                   FROM pg_class,
                    pg_namespace
                  WHERE (pg_class.relnamespace = pg_namespace.oid)) cl ON (((srcch.table_name = cl.relname) AND (srcch.schema_name = cl.schema_name))))
             LEFT JOIN pg_tablespace pgtab ON ((pgtab.oid = cl.reltablespace)))
          WHERE ((srcch.dropped IS FALSE) AND (srcch.osm_chunk IS FALSE) AND (ht.compression_state <> 2))) finalq
  WHERE (finalq.chunk_dimension_num = 1);
timescaledb_information|
compression_settings|
postgres|
 SELECT ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    ((unnest(cs.segmentby))::name COLLATE "C") AS attname,
    (generate_series(1, array_length(cs.segmentby, 1)))::smallint AS segmentby_column_index,
    NULL::smallint AS orderby_column_index,
    NULL::boolean AS orderby_asc,
    NULL::boolean AS orderby_nullsfirst
   FROM (_timescaledb_catalog.hypertable ht
     JOIN _timescaledb_catalog.compression_settings cs ON ((((cs.relid)::oid = ((format('%I.%I'::text, ht.schema_name, ht.table_name))::regclass)::oid) AND (cs.segmentby IS NOT NULL))))
  WHERE (ht.compressed_hypertable_id IS NOT NULL)
UNION ALL
 SELECT ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    ((unnest(cs.orderby))::name COLLATE "C") AS attname,
    NULL::smallint AS segmentby_column_index,
    (generate_series(1, array_length(cs.orderby, 1)))::smallint AS orderby_column_index,
    unnest(array_replace(array_replace(array_replace(cs.orderby_desc, false, NULL::boolean), true, false), NULL::boolean, true)) AS orderby_asc,
    unnest(cs.orderby_nullsfirst) AS orderby_nullsfirst
   FROM (_timescaledb_catalog.hypertable ht
     JOIN _timescaledb_catalog.compression_settings cs ON ((((cs.relid)::oid = ((format('%I.%I'::text, ht.schema_name, ht.table_name))::regclass)::oid) AND (cs.orderby IS NOT NULL))))
  WHERE (ht.compressed_hypertable_id IS NOT NULL)
  ORDER BY 2, 4, 5;
timescaledb_information|
continuous_aggregates|
postgres|
 SELECT ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    cagg.user_view_schema AS view_schema,
    cagg.user_view_name AS view_name,
    viewinfo.viewowner AS view_owner,
    cagg.materialized_only,
        CASE
            WHEN (mat_ht.compressed_hypertable_id IS NOT NULL) THEN true
            ELSE false
        END AS compression_enabled,
    mat_ht.schema_name AS materialization_hypertable_schema,
    mat_ht.table_name AS materialization_hypertable_name,
    directview.viewdefinition AS view_definition,
    cagg.finalized
   FROM _timescaledb_catalog.continuous_agg cagg,
    _timescaledb_catalog.hypertable ht,
    LATERAL ( SELECT c.oid,
            pg_get_userbyid(c.relowner) AS viewowner
           FROM (pg_class c
             LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
          WHERE ((c.relkind = 'v'::"char") AND (c.relname = cagg.user_view_name) AND (n.nspname = cagg.user_view_schema))) viewinfo,
    LATERAL ( SELECT pg_get_viewdef(c.oid) AS viewdefinition
           FROM (pg_class c
             LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))
          WHERE ((c.relkind = 'v'::"char") AND (c.relname = cagg.direct_view_name) AND (n.nspname = cagg.direct_view_schema))) directview,
    LATERAL ( SELECT hypertable.schema_name,
            hypertable.table_name,
            hypertable.compressed_hypertable_id
           FROM _timescaledb_catalog.hypertable
          WHERE (cagg.mat_hypertable_id = hypertable.id)) mat_ht
  WHERE (cagg.raw_hypertable_id = ht.id);
timescaledb_information|
dimensions|
postgres|
 SELECT ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    rank() OVER (PARTITION BY dim.hypertable_id ORDER BY dim.id) AS dimension_number,
    dim.column_name,
    dim.column_type,
        CASE
            WHEN (dim.interval_length IS NULL) THEN 'Space'::text
            ELSE 'Time'::text
        END AS dimension_type,
        CASE
            WHEN (dim.interval_length IS NOT NULL) THEN
            CASE
                WHEN (((dim.column_type)::oid = ('timestamp without time zone'::regtype)::oid) OR ((dim.column_type)::oid = ('timestamp with time zone'::regtype)::oid) OR ((dim.column_type)::oid = ('date'::regtype)::oid)) THEN _timescaledb_functions.to_interval(dim.interval_length)
                ELSE NULL::interval
            END
            ELSE NULL::interval
        END AS time_interval,
        CASE
            WHEN (dim.interval_length IS NOT NULL) THEN
            CASE
                WHEN (((dim.column_type)::oid = ('timestamp without time zone'::regtype)::oid) OR ((dim.column_type)::oid = ('timestamp with time zone'::regtype)::oid) OR ((dim.column_type)::oid = ('date'::regtype)::oid)) THEN NULL::bigint
                ELSE dim.interval_length
            END
            ELSE NULL::bigint
        END AS integer_interval,
    dim.integer_now_func,
    dim.num_slices AS num_partitions
   FROM _timescaledb_catalog.hypertable ht,
    _timescaledb_catalog.dimension dim
  WHERE (dim.hypertable_id = ht.id);
timescaledb_information|
hypertables|
postgres|
 SELECT ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    t.tableowner AS owner,
    ht.num_dimensions,
    ( SELECT count(1) AS count
           FROM _timescaledb_catalog.chunk ch
          WHERE ((ch.hypertable_id = ht.id) AND (ch.dropped IS FALSE) AND (ch.osm_chunk IS FALSE))) AS num_chunks,
        CASE
            WHEN (ht.compression_state = 1) THEN true
            ELSE false
        END AS compression_enabled,
    srchtbs.tablespace_list AS tablespaces
   FROM (((_timescaledb_catalog.hypertable ht
     JOIN pg_tables t ON (((ht.table_name = t.tablename) AND (ht.schema_name = t.schemaname))))
     LEFT JOIN _timescaledb_catalog.continuous_agg ca ON ((ca.mat_hypertable_id = ht.id)))
     LEFT JOIN ( SELECT tablespace.hypertable_id,
            array_agg(tablespace.tablespace_name ORDER BY tablespace.id) AS tablespace_list
           FROM _timescaledb_catalog.tablespace
          GROUP BY tablespace.hypertable_id) srchtbs ON ((ht.id = srchtbs.hypertable_id)))
  WHERE ((ht.compression_state <> 2) AND (ca.mat_hypertable_id IS NULL));
timescaledb_information|
job_errors|
postgres|
 SELECT job_errors.job_id,
    (job_errors.error_data ->> 'proc_schema'::text) AS proc_schema,
    (job_errors.error_data ->> 'proc_name'::text) AS proc_name,
    job_errors.pid,
    job_errors.start_time,
    job_errors.finish_time,
    (job_errors.error_data ->> 'sqlerrcode'::text) AS sqlerrcode,
        CASE
            WHEN ((job_errors.error_data ->> 'message'::text) IS NOT NULL) THEN
            CASE
                WHEN ((job_errors.error_data ->> 'detail'::text) IS NOT NULL) THEN
                CASE
                    WHEN ((job_errors.error_data ->> 'hint'::text) IS NOT NULL) THEN concat((job_errors.error_data ->> 'message'::text), '. ', (job_errors.error_data ->> 'detail'::text), '. ', (job_errors.error_data ->> 'hint'::text))
                    ELSE concat((job_errors.error_data ->> 'message'::text), ' ', (job_errors.error_data ->> 'detail'::text))
                END
                ELSE
                CASE
                    WHEN ((job_errors.error_data ->> 'hint'::text) IS NOT NULL) THEN concat((job_errors.error_data ->> 'message'::text), '. ', (job_errors.error_data ->> 'hint'::text))
                    ELSE (job_errors.error_data ->> 'message'::text)
                END
            END
            ELSE 'job crash detected, see server logs'::text
        END AS err_message
   FROM (_timescaledb_internal.job_errors
     LEFT JOIN _timescaledb_config.bgw_job ON ((bgw_job.id = job_errors.job_id)))
  WHERE ((pg_has_role(CURRENT_USER, ( SELECT pg_get_userbyid(pg_database.datdba) AS pg_get_userbyid
           FROM pg_database
          WHERE (pg_database.datname = current_database())), 'MEMBER'::text) IS TRUE) OR (pg_has_role(CURRENT_USER, (bgw_job.owner)::oid, 'MEMBER'::text) IS TRUE));
timescaledb_information|
job_stats|
postgres|
 SELECT ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    j.id AS job_id,
    js.last_start AS last_run_started_at,
    js.last_successful_finish,
        CASE
            WHEN (js.last_finish < '4714-11-24 00:00:00+00 BC'::timestamp with time zone) THEN NULL::text
            WHEN (js.last_finish IS NOT NULL) THEN
            CASE
                WHEN (js.last_run_success = true) THEN 'Success'::text
                WHEN (js.last_run_success = false) THEN 'Failed'::text
                ELSE NULL::text
            END
            ELSE NULL::text
        END AS last_run_status,
        CASE
            WHEN (pgs.state = 'active'::text) THEN 'Running'::text
            WHEN (j.scheduled = false) THEN 'Paused'::text
            ELSE 'Scheduled'::text
        END AS job_status,
        CASE
            WHEN (js.last_finish > js.last_start) THEN (js.last_finish - js.last_start)
            ELSE NULL::interval
        END AS last_run_duration,
        CASE
            WHEN j.scheduled THEN js.next_start
            ELSE NULL::timestamp with time zone
        END AS next_start,
    js.total_runs,
    js.total_successes,
    js.total_failures
   FROM (((_timescaledb_config.bgw_job j
     JOIN _timescaledb_internal.bgw_job_stat js ON ((j.id = js.job_id)))
     LEFT JOIN _timescaledb_catalog.hypertable ht ON ((j.hypertable_id = ht.id)))
     LEFT JOIN pg_stat_activity pgs ON (((pgs.datname = current_database()) AND (pgs.application_name = j.application_name))))
  ORDER BY ht.schema_name, ht.table_name;
timescaledb_information|
jobs|
postgres|
 SELECT j.id AS job_id,
    j.application_name,
    j.schedule_interval,
    j.max_runtime,
    j.max_retries,
    j.retry_period,
    j.proc_schema,
    j.proc_name,
    j.owner,
    j.scheduled,
    j.fixed_schedule,
    j.config,
    js.next_start,
    j.initial_start,
    ht.schema_name AS hypertable_schema,
    ht.table_name AS hypertable_name,
    j.check_schema,
    j.check_name
   FROM ((_timescaledb_config.bgw_job j
     LEFT JOIN _timescaledb_catalog.hypertable ht ON ((ht.id = j.hypertable_id)))
     LEFT JOIN _timescaledb_internal.bgw_job_stat js ON ((js.job_id = j.id)));

-- ================================================================================
-- TIMESCALEDB CATALOG TABLES
-- ================================================================================
schema_name|
table_name|
columns
_timescaledb_catalog|
chunk|
id integer, hypertable_id integer, schema_name name, table_name name, compressed_chunk_id integer, dropped boolean, status integer, osm_chunk boolean, creation_time timestamp with time zone
_timescaledb_catalog|
chunk_constraint|
chunk_id integer, dimension_slice_id integer, constraint_name name, hypertable_constraint_name name
_timescaledb_catalog|
chunk_index|
chunk_id integer, index_name name, hypertable_id integer, hypertable_index_name name
_timescaledb_catalog|
compression_algorithm|
id smallint, version smallint, name name, description text
_timescaledb_catalog|
compression_chunk_size|
chunk_id integer, compressed_chunk_id integer, uncompressed_heap_size bigint, uncompressed_toast_size bigint, uncompressed_index_size bigint, compressed_heap_size bigint, compressed_toast_size bigint, compressed_index_size bigint, numrows_pre_compression bigint, numrows_post_compression bigint, numrows_frozen_immediately bigint
_timescaledb_catalog|
compression_settings|
relid regclass, segmentby text[], orderby text[], orderby_desc boolean[], orderby_nullsfirst boolean[]
_timescaledb_catalog|
continuous_agg|
mat_hypertable_id integer, raw_hypertable_id integer, parent_mat_hypertable_id integer, user_view_schema name, user_view_name name, partial_view_schema name, partial_view_name name, bucket_width bigint, direct_view_schema name, direct_view_name name, materialized_only boolean, finalized boolean
_timescaledb_catalog|
continuous_agg_migrate_plan|
mat_hypertable_id integer, start_ts timestamp with time zone, end_ts timestamp with time zone, user_view_definition text
_timescaledb_catalog|
continuous_agg_migrate_plan_step|
mat_hypertable_id integer, step_id integer, status text, start_ts timestamp with time zone, end_ts timestamp with time zone, type text, config jsonb
_timescaledb_catalog|
continuous_aggs_bucket_function|
mat_hypertable_id integer, experimental boolean, name text, bucket_width text, origin text, timezone text
_timescaledb_catalog|
continuous_aggs_hypertable_invalidation_log|
hypertable_id integer, lowest_modified_value bigint, greatest_modified_value bigint
_timescaledb_catalog|
continuous_aggs_invalidation_threshold|
hypertable_id integer, watermark bigint
_timescaledb_catalog|
continuous_aggs_materialization_invalidation_log|
materialization_id integer, lowest_modified_value bigint, greatest_modified_value bigint
_timescaledb_catalog|
continuous_aggs_watermark|
mat_hypertable_id integer, watermark bigint
_timescaledb_catalog|
dimension|
id integer, hypertable_id integer, column_name name, column_type regtype, aligned boolean, num_slices smallint, partitioning_func_schema name, partitioning_func name, interval_length bigint, compress_interval_length bigint, integer_now_func_schema name, integer_now_func name
_timescaledb_catalog|
dimension_slice|
id integer, dimension_id integer, range_start bigint, range_end bigint
_timescaledb_catalog|
hypertable|
id integer, schema_name name, table_name name, associated_schema_name name, associated_table_prefix name, num_dimensions smallint, chunk_sizing_func_schema name, chunk_sizing_func_name name, chunk_target_size bigint, compression_state smallint, compressed_hypertable_id integer, status integer
_timescaledb_catalog|
metadata|
key name, value text, include_in_telemetry boolean
_timescaledb_catalog|
tablespace|
id integer, hypertable_id integer, tablespace_name name
_timescaledb_catalog|
telemetry_event|
created timestamp with time zone, tag name, body jsonb
_timescaledb_internal|
bgw_job_stat|
job_id integer, last_start timestamp with time zone, last_finish timestamp with time zone, next_start timestamp with time zone, last_successful_finish timestamp with time zone, last_run_success boolean, total_runs bigint, total_duration interval, total_duration_failures interval, total_successes bigint, total_failures bigint, total_crashes bigint, consecutive_failures integer, consecutive_crashes integer, flags integer
_timescaledb_internal|
bgw_policy_chunk_stats|
job_id integer, chunk_id integer, num_times_job_run integer, last_time_job_run timestamp with time zone
_timescaledb_internal|
job_errors|
job_id integer, pid integer, start_time timestamp with time zone, finish_time timestamp with time zone, error_data jsonb

-- ================================================================================
-- TIMESCALEDB EXTENSION DETAILS
-- ================================================================================
extname|
extversion|
extrelocatable|
schema_name
timescaledb|
2.14.0|
f|
public
